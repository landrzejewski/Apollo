Parser protocol


mapOrDefault

- tests
- filter using flatMap
- zeroOrMore separatedBy with default Parser from Parsers combinators 2  (instance method?)
- onOf Parser from Parsers combinators 3 + variadic parameters Parser Combinators Recap: Part 2 (static)

- int and double parser (based on prefix parser, with a sign)

Based on collectios (Generalisation part 1)
- prefix(String) parser (based on prefix or build in hasPrefix oor range)
- prefix(upTo) and prefix (through) Parsing Xcode Logs: Part 1


- betwen = prefix(upTo) and prefix (through)

- range Parsing Xcode Logs: Part 1

skip/take void (fluet)
take = zipWith

main / executable Parsing Xcode Logs: Part 2

Stream Genralizing part 2


func zip<Input, OutputA, OutputB>(_ firstParser: Parser<Input, OutputA>, _ secondParser: Parser<Input, OutputB>) -> Parser<Input, (OutputA, OutputB)> {
    .init { input in
        switch firstParser.parse(input) {
        case .success(let outputA, let remainder):
            return secondParser.parse(remainder).map { outputB in
                (outputA, outputB)
            }
        case .failure(let cause, let remainder):
            return .failure(cause, remainder)
        }
    }
}

public func success<Input, Output>(_ output: Output) -> Parser<Input, Output> {
    .init { input in
        .success(output, input)
    }
}

public func failure<Input, Output>() -> Parser<Input, Output> {
    Parser { input in
        .failure("", input)
    }
}

extension Parser where Input == Substring, Output == Substring {
    
    public static func prefix(while predicate: @escaping (Character) -> Bool) -> Parser<Substring, Substring> {
        .init { input in
            let prefix = input.prefix(while: predicate)
            if prefix.isEmpty {
                return .failure("Invalid prefix", input)
            }
            return .success(prefix, input[prefix.endIndex...])
        }
    }
    
    public static func prefix(_ value: String) -> Parser<Substring, Substring> {
        .init { _ in
            return .success("", "")
        }
    }
   
}

extension Parser where Input == Substring, Output == Int {
    
    public static let int = Self { _ in
        return .success(32, "")
    }
    
}

let zeroOrMoreSpaces = Parser.prefix(while: { $0 == " " })

let oneOrMoreSpaces = Parser.prefix(while: { $0 == " " })
    .flatMap {
        $0.isEmpty ? failure() : success($0)
    }

extension Parser: ExpressibleByUnicodeScalarLiteral where Input == Substring, Output == Substring {
    
    public typealias UnicodeScalarLiteralType = StringLiteralType
    
}

extension Parser: ExpressibleByExtendedGraphemeClusterLiteral where Input == Substring, Output == Substring {
    
    public typealias ExtendedGraphemeClusterLiteralType = StringLiteralType
    
}

extension Parser: ExpressibleByStringLiteral where Input == Substring, Output == Substring {
   
    public typealias StringLiteralType = String
   
    public init(stringLiteral value: String) {
        self = .prefix(value)
    }
    
}


public struct Parser<Input, Output> {


    func zip<OutputB>(_ secondParser: Parser<Input, OutputB>) -> Parser<Input, (Output, OutputB)> {
        .init { input in
            switch parse(input) {
            case .success(let output, let remainder):
                return secondParser.parse(remainder).combine(with: output, originalRemainder: input)
            case .failure(let cause, let remainder):
                return .failure(cause, remainder)
            }
        }
    }

    func zip<OutputA, OutputB, OutputC>(_ parserC: Parser<Input, OutputC>) -> Parser<Input, (OutputA, OutputB, OutputC)> where Output == (OutputA, OutputB) {
        zip(parserC).map { parsers, parserC in
            (parsers.0, parsers.1, parserC)
        }
    }

    func skip<OtherOutput>(_ parser: Parser<Input, OtherOutput>) -> Parser {
        zip(parser).map { outputA, _ in
            outputA
        }
    }

}
